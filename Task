
ЗАДАЧА: Написать приложение «Морской бой».

1.Интерфейс приложения должен представлять собой консольное окно с двумя полями 6х6 вида:

           ME | a | b | c | d | e | f |         AI | a | b | c | d | e | f |
            1 | ■ | ■ | x | о | о | о |          1 | ■ | ■ | ■ |   | о | о |
            2 | о | о |   | о | ■ | ■ |          2 | о | о | o |   | ■ | ■ |
            3 | о |   |   | о | о | о |          3 | о |   | о | о | о | о |
            4 | ■ | о | ■ | о | ■ |   |          4 | x |   | ■ | о | ■ | о |
            5 | о | о | о | x | ■ | о |          5 | о |   | о | o | ■ |   |
            6 | ■ | о | ■ | о | о | о |          6 | ■ | о | ■ | о | о | о |

2.Количество кораблей: 1 корабль на 3 клетки, 2 корабля на 2 клетки, 4 корабля на одну клетку
3.Игрок играет с компьютером. Компьютер делает ходы наугад, но не ходит по тем клеткам, в которые он уже сходил.
4.Для представления корабля на игровой доске напишите класс Ship (в конструктор передаём информацию о его положении на доске).
5.Опишите класс доски, на которую будут размещаться корабли.
6.Корабли должны находится на расстоянии минимум одна клетка друг от друга.
7.Запретите игроку стрелять в одну и ту же клетку несколько раз. При ошибках хода игрока должно возникать исключение.
8.В случае, если возникают непредвиденные ситуации, выбрасывать и обрабатывать исключения.
9.Буквой "o" помечаются незанятые клетки, "x" - подбитые корабли, " " — промах, а сами корабли символом "■".
10.Побеждает тот, кто быстрее всех разгромит корабли противника.


========================================================================================================================


АЛГОРИТМ РЕШЕНИЯ:

Решать задачу необходимо реализацией нужных классов. Выделим две группы классов:
    - Внутренняя логика игры — корабли, игровая доска и вся логика связанная с ней.
    - Внешняя логика игры — пользовательский интерфейс, искусственный интеллект, игровой контроллер, который считает
      побитые корабли.

1. В начале напишем классы исключений, которые будет использовать программа. Например, когда игрок пытается выстрелить
   в клетку за пределами поля, во внутренней логике должно выбрасываться соответствующее исключение BoardOutException,
   а потом отлавливаться во внешней логике, выводя сообщение об этой ошибке пользователю.

2. Далее нужно реализовать класс Dot — класс точек на поле. Каждая точка описывается параметрами:
    - Координата по оси x .
    - Координата по оси y .
   В программе будем часто обмениваться информацией о точках на поле, поэтому имеет смысл сделать отдельный тип данных для них.
   Очень удобно будет реализовать в этом классе метод __eq__, чтобы точки можно было проверять на равенство. Тогда, чтобы проверить,
   находится ли точка в списке, достаточно просто использовать оператор in.

3. Следующим идёт класс Ship — корабль на игровом поле, который описывается параметрами:
    - Длина.
    - Точка, где размещён нос корабля.
    - Направление корабля (вертикальное/горизонтальное).
    - Количеством жизней (сколько точек корабля ещё не подбито).
   И имеет метод dots, который возвращает список всех точек корабля.

4. Самый важный класс во внутренней логике — класс Board — игровая доска. Доска описывается параметрами:
    - Двумерный список, в котором хранятся состояния каждой из клеток.
    - Список кораблей доски.
    - Параметр hid типа bool — информация о том, нужно ли скрывать корабли на доске (для вывода доски врага) или нет (для своей доски).
    - Количество живых кораблей на доске.
   И имеет методы:
    - Метод add_ship, который ставит корабль на доску (если ставить не получается, выбрасываем исключения).
    - Метод contour, который обводит корабль по контуру. Он будет полезен и в ходе самой игры, и в при расстановке кораблей (помечает
      соседние точки, где корабля по правилам быть не может).
    - Метод, который выводит доску в консоль в зависимости от параметра hid.
    - Метод out, который для точки (объекта класса Dot) возвращает True, если точка выходит за пределы поля, и False, если не выходит.
    - Метод shot, который делает выстрел по доске (если есть попытка выстрелить за пределы и в использованную точку, нужно выбрасывать
      исключения).

5. Далее внешняя логика: класс Player — класс игрока в игру (и AI, и пользователь). Этот класс будет родителем для классов с AI и с
   пользователем. Игрок описывается параметрами:
    - Собственная доска (объект класса Board).
    - Доска врага.
   И имеет следующие методы:
    - ask — метод, который «спрашивает» игрока, в какую клетку он делает выстрел. Пока мы делаем общий для AI и пользователя класс,
      этот метод мы описать не можем. Оставим его пустым. Тем самым обозначим, что потомки должны реализовать этот метод.
    - move — метод, который делает ход в игре. Тут мы вызываем метод ask, делаем выстрел по вражеской доске (метод Board.shot),
      отлавливаем исключения, и если они есть, пытаемся повторить ход. Метод должен возвращать True, если этому игроку нужен повторный
      ход (например, если он выстрелом подбил корабль).

6. Теперь нам остаётся унаследовать классы AI и User от Player и переопределить в них метод ask. Для AI это будет выбор случайной точки,
   а для User этот метод будет спрашивать координаты точки из консоли.

7. После создаём главный класс — класс Game. Игра описывается параметрами:
    - Игрок-пользователь, объект класса User.
    - Доска пользователя.
    - Игрок-компьютер, объект класса AI.
    - Доска компьютера.
   И имеет методы:
    - random_board — метод генерирует случайную доску. Для этого мы просто пытаемся в случайные клетки изначально пустой доски расставлять
      корабли (в бесконечном цикле пытаемся поставить корабль в случайную доску, пока наша попытка не окажется успешной). Лучше расставлять
      сначала длинные корабли, а потом короткие. Если было сделано много (несколько тысяч) попыток установить корабль, но это не получилось,
      значит доска неудачная и на неё корабль уже не добавить. В таком случае нужно начать генерировать новую доску.
    - greet — метод, который в консоли приветствует пользователя и рассказывает о формате ввода.
    - loop — метод с самим игровым циклом. Там мы просто последовательно вызываем метод move для игроков и делаем проверку, сколько живых
      кораблей осталось на досках, чтобы определить победу.
    - start — запуск игры. Сначала вызываем greet, а потом loop.

8. Останется создать экземпляр класса Game и вызвать метод start.